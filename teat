local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = Workspace.CurrentCamera

local Shared = getgenv().SchmecktHubPC or {}
getgenv().SchmecktHubPC = Shared

local key = "SilentAimFOV"
if Shared.Connections and Shared.Connections[key] then
    for _, c in pairs(Shared.Connections[key]) do pcall(function() c:Disconnect() end) end
end
Shared.Connections = Shared.Connections or {}
Shared.Connections[key] = {}

local FOV = 130
local Target, Part, Pos = nil, nil, nil
local Data = {}

local Bones = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "Torso"}

pcall(function()
    if CoreGui:FindFirstChild("SchmecktSilent") then CoreGui.SchmecktSilent:Destroy() end
    if Workspace:FindFirstChild("SilentAimHL") then Workspace.SilentAimHL:Destroy() end
end)

local UI = Instance.new("ScreenGui")
UI.Name = "SchmecktSilent"
UI.ResetOnSpawn = false
UI.IgnoreGuiInset = true
if syn and syn.protect_gui then syn.protect_gui(UI) end
UI.Parent = CoreGui

local Circle = Instance.new("Frame")
Circle.AnchorPoint = Vector2.new(0.5, 0.5)
Circle.BackgroundTransparency = 1
Circle.Size = UDim2.new(0, FOV * 2, 0, FOV * 2)
Circle.Parent = UI
Instance.new("UICorner", Circle).CornerRadius = UDim.new(1, 0)
local Stroke = Instance.new("UIStroke", Circle)
Stroke.Color = Color3.fromRGB(255, 255, 255)
Stroke.Thickness = 1.5
Stroke.Transparency = 0.3

local HL = Instance.new("Highlight")
HL.Name = "SilentAimHL"
HL.FillColor = Color3.fromRGB(255, 50, 50)
HL.FillTransparency = 0.65
HL.OutlineColor = Color3.fromRGB(255, 255, 255)
HL.OutlineTransparency = 0
HL.Enabled = false
HL.Parent = Workspace

local Slider = Instance.new("Frame")
Slider.AnchorPoint = Vector2.new(0, 1)
Slider.Position = UDim2.new(0, 10, 1, -10)
Slider.Size = UDim2.new(0, 180, 0, 32)
Slider.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
Slider.BorderSizePixel = 0
Slider.Parent = UI
Instance.new("UICorner", Slider).CornerRadius = UDim.new(0, 8)

local Label = Instance.new("TextLabel")
Label.Size = UDim2.new(1, 0, 1, 0)
Label.BackgroundTransparency = 1
Label.Text = "FOV: " .. FOV
Label.TextColor3 = Color3.fromRGB(255, 255, 255)
Label.Font = Enum.Font.GothamBold
Label.TextSize = 13
Label.Parent = Slider

local Track = Instance.new("Frame")
Track.AnchorPoint = Vector2.new(0.5, 0.5)
Track.Position = UDim2.new(0.5, 0, 0.5, 0)
Track.Size = UDim2.new(0.55, 0, 0, 4)
Track.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
Track.BorderSizePixel = 0
Track.Parent = Slider
Instance.new("UICorner", Track).CornerRadius = UDim.new(1, 0)

local Knob = Instance.new("Frame")
Knob.Size = UDim2.new(0, 12, 0, 12)
Knob.AnchorPoint = Vector2.new(0.5, 0.5)
Knob.Position = UDim2.new((FOV - 40) / 260, 0, 0.5, 0)
Knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Knob.BorderSizePixel = 0
Knob.Parent = Track
Instance.new("UICorner", Knob).CornerRadius = UDim.new(1, 0)

local Dragging = false

table.insert(Shared.Connections[key], Track.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 then Dragging = true end end))
table.insert(Shared.Connections[key], Knob.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 then Dragging = true end end))
table.insert(Shared.Connections[key], UserInputService.InputEnded:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 then Dragging = false end end))
table.insert(Shared.Connections[key], UserInputService.InputChanged:Connect(function(i)
    if Dragging and i.UserInputType == Enum.UserInputType.MouseMovement then
        local a = math.clamp((i.Position.X - Track.AbsolutePosition.X) / Track.AbsoluteSize.X, 0, 1)
        FOV = math.floor(40 + 260 * a)
        Knob.Position = UDim2.new(a, 0, 0.5, 0)
        Circle.Size = UDim2.new(0, FOV * 2, 0, FOV * 2)
        Label.Text = "FOV: " .. FOV
    end
end))

local function Visible(char, part)
    local cam = Camera
    local myChar = LP.Character
    if not cam or not myChar or not part then return false end
    local origin = cam.CFrame.Position
    local dir = (part.Position - origin)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {myChar, char}
    local ray = Workspace:Raycast(origin, dir, params)
    return ray == nil
end

local function GetData(plr, hrp)
    local t = tick()
    local v = hrp.AssemblyLinearVelocity or Vector3.zero
    if not Data[plr] then
        Data[plr] = {vel = {}, lastVel = v, lastT = t}
    end
    local d = Data[plr]
    local dt = t - d.lastT
    if dt > 0.016 then
        table.insert(d.vel, 1, v)
        if #d.vel > 8 then table.remove(d.vel) end
        d.lastVel = v
        d.lastT = t
    end
    return d
end

local function Predict(plr, bone, hrp, dist)
    local d = GetData(plr, hrp)
    local avgVel = Vector3.zero
    if #d.vel > 0 then
        for _, v in ipairs(d.vel) do avgVel = avgVel + v end
        avgVel = avgVel / #d.vel
    end
    if avgVel.Magnitude < 0.5 then return bone.Position end
    local ping = 0.05
    pcall(function() ping = LP:GetNetworkPing() end)
    local t = (dist / 900) + (ping * 1.1)
    local pred = bone.Position + (avgVel * t)
    pred = Vector3.new(pred.X, math.clamp(pred.Y, hrp.Position.Y - 3, hrp.Position.Y + 3.5), pred.Z)
    return pred
end

local function GetBestTarget()
    local cam = Camera
    if not cam then return nil, nil, nil end
    local mp = UserInputService:GetMouseLocation()
    local best = {score = math.huge, char = nil, part = nil, pos = nil}
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr == LP then continue end
        local char = plr.Character
        if not char then continue end
        local hum = char:FindFirstChild("Humanoid")
        if not hum or hum.Health <= 0 then continue end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then continue end
        for _, boneName in ipairs(Bones) do
            local bone = char:FindFirstChild(boneName)
            if not bone then continue end
            local sp, onScreen = cam:WorldToViewportPoint(bone.Position)
            if not onScreen then continue end
            local screenDist = (Vector2.new(sp.X, sp.Y) - mp).Magnitude
            if screenDist > FOV then continue end
            if not Visible(char, bone) then continue end
            if screenDist < best.score then
                best.score = screenDist
                best.char = char
                best.part = bone
                best.pos = Predict(plr, bone, hrp, (bone.Position - cam.CFrame.Position).Magnitude)
            end
        end
    end
    return best.char, best.part, best.pos
end

task.spawn(function()
    while true do
        task.wait(5)
        for p in pairs(Data) do
            if not p or not p.Parent then Data[p] = nil end
        end
    end
end)

table.insert(Shared.Connections[key], RunService.RenderStepped:Connect(function()
    Camera = Workspace.CurrentCamera
    
    -- EINZIGE ÄNDERUNG: Prüft auch die Methode
    if not Shared.SilentAim or Shared.SilentAimMethod ~= "FOV" then
        UI.Enabled = false
        HL.Enabled = false
        Target, Part, Pos = nil, nil, nil
        return
    end
    
    UI.Enabled = true
    local mp = UserInputService:GetMouseLocation()
    Circle.Position = UDim2.new(0, mp.X, 0, mp.Y)
    Target, Part, Pos = GetBestTarget()
    if Target then
        HL.Adornee = Target
        HL.Enabled = true
        Stroke.Color = Color3.fromRGB(255, 50, 50)
    else
        HL.Enabled = false
        Stroke.Color = Color3.fromRGB(255, 255, 255)
    end
end))

local mt = getrawmetatable(game)
local oldNc = mt.__namecall
local oldIdx = mt.__index
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local m = getnamecallmethod()
    local a = {...}
    
    -- EINZIGE ÄNDERUNG: Prüft auch die Methode
    if Shared.SilentAim and Shared.SilentAimMethod == "FOV" and Target and Pos then
        if m == "Raycast" and self == Workspace then
            if a[1] and a[2] then
                a[2] = (Pos - a[1]).Unit * a[2].Magnitude
                return oldNc(self, unpack(a))
            end
        end
        if self == Mouse then
            if m == "GetHit" then return CFrame.new(Pos) end
            if m == "GetTarget" then return Part end
        end
        if self == Camera and (m == "ViewportPointToRay" or m == "ScreenPointToRay") then
            return Ray.new(Camera.CFrame.Position, (Pos - Camera.CFrame.Position).Unit)
        end
    end
    return oldNc(self, ...)
end)

mt.__index = newcclosure(function(self, k)
    -- EINZIGE ÄNDERUNG: Prüft auch die Methode
    if Shared.SilentAim and Shared.SilentAimMethod == "FOV" and Target and Pos and self == Mouse then
        if k == "Hit" then return CFrame.new(Pos) end
        if k == "Target" then return Part end
        if k == "X" then return Pos.X end
        if k == "Y" then return Pos.Y end
        if k == "Z" then return Pos.Z end
        if k == "UnitRay" then return Ray.new(Camera.CFrame.Position, (Pos - Camera.CFrame.Position).Unit) end
    end
    return oldIdx(self, k)
end)

setreadonly(mt, true)
