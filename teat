--// SCHMECKT SILENT AIM – SAFE + FOV‑SLIDER LINKS UNTEN + ANTI‑ANTI‑LOCK //--

local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local Workspace         = game:GetService("Workspace")
local CoreGui           = game:GetService("CoreGui")
local UserInputService  = game:GetService("UserInputService")

local lp     = Players.LocalPlayer
local mouse  = lp:GetMouse()
local camera = Workspace.CurrentCamera

-- Doppel-Hook verhindern
if getgenv().SchmecktSilentHooked then
    warn("[SchmecktSilent] already hooked")
    return
end
getgenv().SchmecktSilentHooked = true

--------------------------------------------------------------------
-- BASE SETTINGS
--------------------------------------------------------------------
local FOV_RADIUS        = 110        -- Start‑FOV
local FOV_MIN           = 40         -- Minimaler FOV
local FOV_MAX           = 260        -- Maximaler FOV

local HIT_PART          = "Head"     -- "Head", "UpperTorso", "HumanoidRootPart" (nur Start-Priorität)
local ENABLE_PREDICTION = true
local CHECK_WALLS       = true

-- Prediction‑Tuning (Basis)
local BULLET_SPEED  = 400            -- Studs/sec (optional, wenn Waffe speed-basiert simuliert)
local BASE_TIME     = 0.03           -- Grunddelay
local PING_WEIGHT   = 0.5            -- wie stark Ping mit reinzählt

-- FOV‑Kreis Optik
local SHOW_FOV_CIRCLE = true
local FOV_COLOR       = Color3.fromRGB(255, 255, 255)
local FOV_THICKNESS   = 2

--------------------------------------------------------------------
-- ANTI‑ANTI‑LOCK SETTINGS
--------------------------------------------------------------------
local AAL = {
    UseMultiPart = true,                    -- Head > UpperTorso > LowerTorso > HRP
    PartsOrder   = {"Head","UpperTorso","LowerTorso","HumanoidRootPart"},
    StickyTime   = 0.25,                    -- hält Lock kurz bei Jitter
    FOVExtraWhenLocked = 26,                -- FOV-Puffer wenn gelockt, damit kein Drop
    UseVelocitySmoothing = true,            -- smoothed Velocity
    SmoothWindow  = 8,                      -- wie viele Frames mitteln
    SmoothAlpha   = 0.7,                    -- Gewicht aktuelle Velocity
    UseAcceleration = true,                 -- Accel für noch bessere Prediction
    AccelWeight   = 0.5,                    -- Gewicht Accel-Anteil
    SoftAimLerp   = 0.35,                   -- sanftes Nachziehen des Zielpunkts
}

--------------------------------------------------------------------
-- STATE / RESOLVER STATE
--------------------------------------------------------------------
local SilentTargetChar   = nil      -- Character des Ziels
local SilentTargetPart   = nil      -- Part des Ziels
local SilentHitPosition  = nil      -- Vector3 (mit Prediction)

local lastTarget         = nil
local lastSeenTime       = 0
local lastAimPos         = nil

-- History: pos/vel für Smoothing/Accel (pro Player)
local Hist = {} -- [player] = {vels = {Vector3...}, times = {t...}}

--------------------------------------------------------------------
-- UI: alte FOV-Circles/Highlight killen
--------------------------------------------------------------------
do
    local oldFov = CoreGui:FindFirstChild("SchmecktSilentFOV")
    if oldFov then oldFov:Destroy() end
    local oldHl = CoreGui:FindFirstChild("SchmecktSilentHighlight")
    if oldHl then oldHl:Destroy() end
end

local fovGui = Instance.new("ScreenGui")
fovGui.Name = "SchmecktSilentFOV"
fovGui.ResetOnSpawn = false
fovGui.IgnoreGuiInset = true
fovGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
fovGui.Parent = CoreGui

-- FOV‑Kreis
local fovCircle = Instance.new("Frame")
fovCircle.Name = "FOVCircle"
fovCircle.AnchorPoint = Vector2.new(0.5, 0.5)
fovCircle.BackgroundTransparency = 1
fovCircle.BorderSizePixel = 0
fovCircle.Size = UDim2.new(0, FOV_RADIUS * 2, 0, FOV_RADIUS * 2)
fovCircle.Position = UDim2.new(0, mouse.X, 0, mouse.Y)
fovCircle.Visible = SHOW_FOV_CIRCLE
fovCircle.Parent = fovGui

local stroke = Instance.new("UIStroke")
stroke.Color = FOV_COLOR
stroke.Thickness = FOV_THICKNESS
stroke.Transparency = 0.2
stroke.Parent = fovCircle

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(1, 0)
corner.Parent = fovCircle

local function updateFovCircle()
    if not SHOW_FOV_CIRCLE then
        fovCircle.Visible = false
        return
    end
    fovCircle.Visible = true
    fovCircle.Size = UDim2.new(0, FOV_RADIUS * 2, 0, FOV_RADIUS * 2)
    fovCircle.Position = UDim2.new(0, mouse.X, 0, mouse.Y)
end

-- Highlight (deutlich rot)
local highlight = Instance.new("Highlight")
highlight.Name = "SchmecktSilentHighlight"
highlight.FillColor = Color3.fromRGB(255, 70, 70)
highlight.FillTransparency = 0.6
highlight.OutlineColor = Color3.new(1, 1, 1)
highlight.OutlineTransparency = 0
highlight.Enabled = false
highlight.Parent = CoreGui

local function updateHighlight()
    if SilentTargetChar then
        highlight.Adornee = SilentTargetChar
        highlight.Enabled = true
    else
        highlight.Adornee = nil
        highlight.Enabled = false
    end
end

--------------------------------------------------------------------
-- FOV‑SLIDER LINKS UNTEN
--------------------------------------------------------------------
local sliderFrame = Instance.new("Frame")
sliderFrame.Name = "FOVSlider"
sliderFrame.AnchorPoint = Vector2.new(0, 1)
sliderFrame.Position = UDim2.new(0, 10, 1, -10)
sliderFrame.Size = UDim2.new(0, 180, 0, 36)
sliderFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
sliderFrame.BackgroundTransparency = 0.15
sliderFrame.BorderSizePixel = 0
sliderFrame.Parent = fovGui
Instance.new("UICorner", sliderFrame).CornerRadius = UDim.new(0, 8)
local sliderStroke = Instance.new("UIStroke")
sliderStroke.Color = Color3.fromRGB(255, 255, 255)
sliderStroke.Thickness = 1
sliderStroke.Transparency = 0.7
sliderStroke.Parent = sliderFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.BackgroundTransparency = 1
titleLabel.Size = UDim2.new(0, 40, 1, 0)
titleLabel.Position = UDim2.new(0, 6, 0, 0)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.Text = "FOV"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 14
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = sliderFrame

local valueLabel = Instance.new("TextLabel")
valueLabel.BackgroundTransparency = 1
valueLabel.Size = UDim2.new(0, 40, 1, 0)
valueLabel.AnchorPoint = Vector2.new(1, 0)
valueLabel.Position = UDim2.new(1, -4, 0, 0)
valueLabel.Font = Enum.Font.Gotham
valueLabel.Text = tostring(FOV_RADIUS)
valueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
valueLabel.TextSize = 13
valueLabel.TextXAlignment = Enum.TextXAlignment.Right
valueLabel.Parent = sliderFrame

local track = Instance.new("Frame")
track.Name = "Track"
track.AnchorPoint = Vector2.new(0, 0.5)
track.Position = UDim2.new(0, 40, 0.5, 0)
track.Size = UDim2.new(1, -80, 0, 6)
track.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
track.BorderSizePixel = 0
track.Parent = sliderFrame
Instance.new("UICorner", track).CornerRadius = UDim.new(0, 3)

local knob = Instance.new("Frame")
knob.Name = "Knob"
knob.Size = UDim2.new(0, 12, 0, 18)
knob.AnchorPoint = Vector2.new(0.5, 0.5)
knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
knob.BorderSizePixel = 0
knob.Parent = track
Instance.new("UICorner", knob).CornerRadius = UDim.new(1, 0)

local function radiusToAlpha()
    return (FOV_RADIUS - FOV_MIN) / (FOV_MAX - FOV_MIN)
end

local function setFOVFromAlpha(a)
    a = math.clamp(a, 0, 1)
    knob.Position = UDim2.new(a, 0, 0.5, 0)
    FOV_RADIUS = math.floor(FOV_MIN + (FOV_MAX - FOV_MIN) * a + 0.5)
    valueLabel.Text = tostring(FOV_RADIUS)
end
setFOVFromAlpha(radiusToAlpha())

local dragging = false
local function getAlphaFromX(x)
    local absPos  = track.AbsolutePosition.X
    local absSize = track.AbsoluteSize.X
    if absSize <= 0 then return 0 end
    return (x - absPos) / absSize
end
track.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        setFOVFromAlpha(getAlphaFromX(input.Position.X))
    end
end)
knob.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1
    or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement
    or input.UserInputType == Enum.UserInputType.Touch) then
        setFOVFromAlpha(getAlphaFromX(input.Position.X))
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1
    or input.UserInputType == Enum.UserInputType.Touch then
        dragging = false
    end
end)

--------------------------------------------------------------------
-- ROBUST PING (ohne Plugin-Capability-Fehler)
--------------------------------------------------------------------
local function getPingSeconds_safe()
    local ok, ping = pcall(function()
        return lp:GetNetworkPing()
    end)
    return (ok and ping) and ping or 0.08
end

--------------------------------------------------------------------
-- PREDICTION / RESOLVER
--------------------------------------------------------------------
local function estimateVelocitySmooth(plr, currentVel)
    if not AAL.UseVelocitySmoothing then
        return currentVel
    end
    Hist[plr] = Hist[plr] or {vels={}, times={}}
    local h = Hist[plr]
    table.insert(h.vels, currentVel)
    table.insert(h.times, tick())
    if #h.vels > AAL.SmoothWindow then
        table.remove(h.vels, 1)
        table.remove(h.times, 1)
    end
    local sum = Vector3.new()
    for i=1,#h.vels do sum += h.vels[i] end
    local avg = sum / math.max(#h.vels, 1)
    -- Lerp Richtung “aktuellem” Wert
    return avg:Lerp(currentVel, AAL.SmoothAlpha)
end

local function estimateAcceleration(plr)
    if not AAL.UseAcceleration then return Vector3.new() end
    local h = Hist[plr]
    if not h or #h.vels < 2 then return Vector3.new() end
    local v2, v1 = h.vels[#h.vels], h.vels[#h.vels-1]
    local t2, t1 = h.times[#h.times], h.times[#h.times-1]
    local dt = math.max(t2 - t1, 1/240)
    return (v2 - v1) / dt
end

local function getPredictedPos_resolved(plr, char, part)
    if not ENABLE_PREDICTION then
        return part.Position
    end
    camera = Workspace.CurrentCamera or camera
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local vel = hrp and (hrp.AssemblyLinearVelocity or hrp.Velocity) or Vector3.new()
    vel = estimateVelocitySmooth(plr, vel)

    local dist = (part.Position - camera.CFrame.Position).Magnitude
    -- Alternative Prediction: aus Ping (robust)
    local tPing = getPingSeconds_safe() * PING_WEIGHT
    local tBall = (BULLET_SPEED > 0) and (BASE_TIME + dist / BULLET_SPEED) or BASE_TIME
    local t = tBall + tPing
    t = math.clamp(t, 0.01, 0.4)

    local accel = estimateAcceleration(plr) * (AAL.AccelWeight)
    local predicted = part.Position + vel * t + 0.5 * accel * (t * t)

    -- Soft aim (sanfter Übergang)
    if lastAimPos then
        predicted = lastAimPos:Lerp(predicted, AAL.SoftAimLerp)
    end
    lastAimPos = predicted
    return predicted
end

--------------------------------------------------------------------
-- WALLCHECK (Cloak‑Bypass bleibt)
--------------------------------------------------------------------
local function isVisible(char, part)
    if not CHECK_WALLS then return true end
    camera = Workspace.CurrentCamera or camera
    if not camera or not part then return false end

    local origin    = camera.CFrame.Position
    local direction = part.Position - origin

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {lp.Character, char}
    params.IgnoreWater = true

    local result = Workspace:Raycast(origin, direction, params)
    if not result then return true end
    if result.Instance and result.Instance:IsDescendantOf(char) then return true end
    return false
end

--------------------------------------------------------------------
-- PART-SELEKTOR MIT FALLBACK (AAL.UseMultiPart)
--------------------------------------------------------------------
local function pickBestPart(char)
    if not AAL.UseMultiPart then
        return char:FindFirstChild(HIT_PART)
    end
    for _, name in ipairs(AAL.PartsOrder) do
        local p = char:FindFirstChild(name)
        if p and isVisible(char, p) then
            return p
        end
    end
    -- Kein sichtbarer? nimm HEAD/HRP egal Sicht (zur Not)
    return char:FindFirstChild("Head") or char:FindFirstChild("HumanoidRootPart")
end

--------------------------------------------------------------------
-- TARGET‑SUCHE (mit Sticky & FOV‑Puffer)
--------------------------------------------------------------------
local function findBestTarget()
    camera = Workspace.CurrentCamera or camera
    if not camera then
        SilentTargetChar  = nil
        SilentTargetPart  = nil
        SilentHitPosition = nil
        lastTarget        = nil
        return
    end

    local bestChar, bestPart, bestPos
    local maxFOV = FOV_RADIUS
    if lastTarget then
        -- FOV-Puffer wenn gelockt (Anti‑Jitter/Anti‑Lock)
        maxFOV = FOV_RADIUS + AAL.FOVExtraWhenLocked
    end

    local shortest = maxFOV
    local mousePos = Vector2.new(mouse.X, mouse.Y)

    -- Kandidaten scannen
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= lp and plr.Character then
            local char = plr.Character
            local hum  = char:FindFirstChildOfClass("Humanoid")
            if hum and hum.Health > 0 then
                local part = pickBestPart(char)
                if part then
                    local screenPos, onScreen = camera:WorldToViewportPoint(part.Position)
                    if onScreen and isVisible(char, part) then
                        local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                        if dist < shortest then
                            shortest = dist
                            bestChar = char
                            bestPart = part
                        end
                    end
                end
            end
        end
    end

    -- Sticky: wenn nichts gefunden, aber letztes Ziel kürzlich gesehen
    if (not bestChar) and lastTarget and (tick() - lastSeenTime <= AAL.StickyTime) then
        if lastTarget.Character then
            bestChar = lastTarget.Character
            bestPart = pickBestPart(bestChar)
        end
    end

    if bestChar and bestPart then
        local ownerPlr = Players:GetPlayerFromCharacter(bestChar)
        local aimPos = getPredictedPos_resolved(ownerPlr, bestChar, bestPart)
        SilentTargetChar  = bestChar
        SilentTargetPart  = bestPart
        SilentHitPosition = aimPos
        lastTarget        = ownerPlr
        lastSeenTime      = tick()
    else
        SilentTargetChar  = nil
        SilentTargetPart  = nil
        SilentHitPosition = nil
        -- lastTarget bleibt (für Sticky-Fenster), lastSeenTime bleibt
    end
end

--------------------------------------------------------------------
-- __index‑HOOK: liest NUR vorberechnete Werte (kein Kamera-Freeze)
--------------------------------------------------------------------
do
    local ok, mt = pcall(getrawmetatable, game)
    if ok and mt then
        local ro = (make_writeable or setreadonly)
        if setreadonly then pcall(setreadonly, mt, false) end
        local oldIndex = mt.__index
        mt.__index = function(t, k)
            if t == mouse and (k == "Hit" or k == "Target") then
                if SilentTargetPart and SilentHitPosition then
                    if k == "Hit" then
                        return CFrame.new(SilentHitPosition)
                    else
                        return SilentTargetPart
                    end
                end
            end
            return oldIndex(t, k)
        end
        -- kein readonly zurücksetzen (wie in deinem Original)
    end
end

--------------------------------------------------------------------
-- RenderStepped Loop
--------------------------------------------------------------------
RunService.RenderStepped:Connect(function()
    updateFovCircle()
    findBestTarget()
    updateHighlight()
end)
