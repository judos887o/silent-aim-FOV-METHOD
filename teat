local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local Stats = game:GetService("Stats")

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = Workspace.CurrentCamera
local CachedMouse = LP:GetMouse()

local Shared = getgenv().SchmecktHubPC or {}
getgenv().SchmecktHubPC = Shared

Shared.SilentAim = true
Shared.SilentAimMethod = "FOV"

local key = "SilentAimFOV"
if Shared.Connections and Shared.Connections[key] then
    for _, c in pairs(Shared.Connections[key]) do pcall(function() c:Disconnect() end) end
end
Shared.Connections = Shared.Connections or {}
Shared.Connections[key] = {}

local FOV = 130
local PREDICTION = 0.136
local Target, Part, Pos = nil, nil, nil
local IsGunEquipped = false
local IsStomping = false

local Bones = {"HumanoidRootPart", "UpperTorso", "Head"}

pcall(function()
    if CoreGui:FindFirstChild("SchmecktSilent") then CoreGui.SchmecktSilent:Destroy() end
end)

local UI = Instance.new("ScreenGui")
UI.Name = "SchmecktSilent"
UI.ResetOnSpawn = false
UI.IgnoreGuiInset = true
if syn and syn.protect_gui then syn.protect_gui(UI) end
UI.Parent = CoreGui

local Circle = Instance.new("Frame")
Circle.AnchorPoint = Vector2.new(0.5, 0.5)
Circle.BackgroundTransparency = 1
Circle.Size = UDim2.new(0, FOV * 2, 0, FOV * 2)
Circle.Parent = UI
Instance.new("UICorner", Circle).CornerRadius = UDim.new(1, 0)
local Stroke = Instance.new("UIStroke", Circle)
Stroke.Color = Color3.fromRGB(255, 255, 255)
Stroke.Thickness = 1.5
Stroke.Transparency = 0.3

local TargetMarker = Instance.new("Frame")
TargetMarker.Size = UDim2.new(0, 10, 0, 10)
TargetMarker.AnchorPoint = Vector2.new(0.5, 0.5)
TargetMarker.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
TargetMarker.BorderSizePixel = 0
TargetMarker.Visible = false
TargetMarker.Parent = UI
Instance.new("UICorner", TargetMarker).CornerRadius = UDim.new(1, 0)

local Slider = Instance.new("Frame")
Slider.AnchorPoint = Vector2.new(0, 1)
Slider.Position = UDim2.new(0, 10, 1, -10)
Slider.Size = UDim2.new(0, 180, 0, 32)
Slider.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
Slider.BorderSizePixel = 0
Slider.Parent = UI
Instance.new("UICorner", Slider).CornerRadius = UDim.new(0, 8)

local Label = Instance.new("TextLabel")
Label.Size = UDim2.new(1, 0, 1, 0)
Label.BackgroundTransparency = 1
Label.Text = "FOV: " .. FOV
Label.TextColor3 = Color3.fromRGB(255, 255, 255)
Label.Font = Enum.Font.GothamBold
Label.TextSize = 13
Label.Parent = Slider

local Track = Instance.new("Frame")
Track.AnchorPoint = Vector2.new(0.5, 0.5)
Track.Position = UDim2.new(0.5, 0, 0.5, 0)
Track.Size = UDim2.new(0.55, 0, 0, 4)
Track.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
Track.BorderSizePixel = 0
Track.Parent = Slider
Instance.new("UICorner", Track).CornerRadius = UDim.new(1, 0)

local Knob = Instance.new("Frame")
Knob.Size = UDim2.new(0, 12, 0, 12)
Knob.AnchorPoint = Vector2.new(0.5, 0.5)
Knob.Position = UDim2.new((FOV - 40) / 260, 0, 0.5, 0)
Knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Knob.BorderSizePixel = 0
Knob.Parent = Track
Instance.new("UICorner", Knob).CornerRadius = UDim.new(1, 0)

local Dragging = false

local function UpdateSlider(input)
    if Track.AbsoluteSize.X == 0 then return end
    
    local pos = math.clamp((input.Position.X - Track.AbsolutePosition.X) / Track.AbsoluteSize.X, 0, 1)
    local newFOV = math.floor(40 + (260 * pos))
    
    FOV = newFOV
    Knob.Position = UDim2.new(pos, 0, 0.5, 0)
    Circle.Size = UDim2.new(0, FOV * 2, 0, FOV * 2)
    Label.Text = "FOV: " .. FOV
end

table.insert(Shared.Connections[key], Track.InputBegan:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton1 then
        Dragging = true
        UpdateSlider(i)
    end
end))

table.insert(Shared.Connections[key], Knob.InputBegan:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton1 then
        Dragging = true
        UpdateSlider(i)
    end
end))

table.insert(Shared.Connections[key], UserInputService.InputEnded:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton1 then
        Dragging = false
    end
end))

table.insert(Shared.Connections[key], UserInputService.InputChanged:Connect(function(i)
    if Dragging and i.UserInputType == Enum.UserInputType.MouseMovement then
        UpdateSlider(i)
    end
end))

table.insert(Shared.Connections[key], UserInputService.InputBegan:Connect(function(i, gp)
    if not gp and i.KeyCode == Enum.KeyCode.E then
        IsStomping = true
    end
end))

table.insert(Shared.Connections[key], UserInputService.InputEnded:Connect(function(i)
    if i.KeyCode == Enum.KeyCode.E then
        IsStomping = false
    end
end))

local function CheckGun()
    local char = LP.Character
    if not char then return false end
    local tool = char:FindFirstChildOfClass("Tool")
    if not tool then return false end
    if tool:FindFirstChild("Handle") and not tool.Name:lower():find("wallet") and not tool.Name:lower():find("phone") then
        return true
    end
    return false
end

local function IsKnocked(char)
    if not char then return true end
    local bodyEffects = char:FindFirstChild("BodyEffects")
    if bodyEffects then
        local ko = bodyEffects:FindFirstChild("K.O")
        if ko and ko.Value == true then return true end
    end
    if char:FindFirstChild("GRABBING_CONSTRAINT") then return true end
    local hum = char:FindFirstChild("Humanoid")
    if hum and hum.Health < 2 then return true end
    return false
end

local function Visible(char, part)
    local myChar = LP.Character
    if not myChar or not part then return false end
    local origin = Camera.CFrame.Position
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {myChar, char}
    local ray = Workspace:Raycast(origin, (part.Position - origin), params)
    return ray == nil
end

local function Predict(plr, bone, hrp)
    local vel = hrp.AssemblyLinearVelocity
    local hum = plr.Character:FindFirstChild("Humanoid")
    
    if vel.Magnitude < 0.1 then return bone.Position end
    
    if hum and hum.MoveDirection.Magnitude > 0 then
        return bone.Position + (hum.MoveDirection * 16 * PREDICTION)
    end
    
    if vel.Y < -20 then
        return bone.Position + (Vector3.new(vel.X, 0, vel.Z) * PREDICTION)
    end
    
    return bone.Position + (vel * PREDICTION)
end

local function GetBestTarget()
    local mp = UserInputService:GetMouseLocation()
    local best = {score = math.huge, char = nil, part = nil, pos = nil}
    
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr == LP then continue end
        
        local char = plr.Character
        if not char then continue end
        
        if IsKnocked(char) then continue end
        
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then continue end
        
        for _, boneName in ipairs(Bones) do
            local bone = char:FindFirstChild(boneName)
            if not bone then continue end
            
            local sp, onScreen = Camera:WorldToViewportPoint(bone.Position)
            if not onScreen then continue end
            
            local screenDist = (Vector2.new(sp.X, sp.Y) - mp).Magnitude
            if screenDist > FOV then continue end
            
            if not Visible(char, bone) then continue end
            
            if screenDist < best.score then
                best.score = screenDist
                best.char = char
                best.part = bone
                best.pos = Predict(plr, bone, hrp)
            end
        end
    end
    
    return best.char, best.part, best.pos
end

table.insert(Shared.Connections[key], RunService.RenderStepped:Connect(function()
    if not Shared.SilentAim or Shared.SilentAimMethod ~= "FOV" then
        UI.Enabled = false
        Target, Part, Pos = nil, nil, nil
        IsGunEquipped = false
        return
    end
    
    UI.Enabled = true
    local mousePos = UserInputService:GetMouseLocation()
    Circle.Position = UDim2.new(0, mousePos.X, 0, mousePos.Y)
    
    if IsStomping then
        Target, Part, Pos = nil, nil, nil
        Stroke.Color = Color3.fromRGB(255, 255, 255)
        TargetMarker.Visible = false
        IsGunEquipped = false
        return
    end

    IsGunEquipped = CheckGun()
    
    if IsGunEquipped then
        Target, Part, Pos = GetBestTarget()
        if Target then
            Stroke.Color = Color3.fromRGB(255, 50, 50)
            
            local screenPos, onScreen = Camera:WorldToViewportPoint(Part.Position)
            if onScreen then
                TargetMarker.Visible = true
                TargetMarker.Position = UDim2.new(0, screenPos.X, 0, screenPos.Y)
            else
                TargetMarker.Visible = false
            end
        else
            Stroke.Color = Color3.fromRGB(255, 255, 255)
            TargetMarker.Visible = false
        end
    else
        Target, Part, Pos = nil, nil, nil
        Stroke.Color = Color3.fromRGB(255, 255, 255)
        TargetMarker.Visible = false
    end
end))

local mt = getrawmetatable(game)
local oldNc = mt.__namecall
local oldIdx = mt.__index
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local m = getnamecallmethod()
    
    if IsGunEquipped and Target and Pos and not IsStomping then
        if m == "Raycast" and self == Workspace then
            local a = {...}
            if a[1] and a[2] then
                return oldNc(self, a[1], (Pos - a[1]).Unit * a[2].Magnitude, unpack(a, 3))
            end
        end
        
        if self == CachedMouse then
            if m == "GetHit" then return CFrame.new(Pos) end
            if m == "GetTarget" then return Part end
        end
    end
    return oldNc(self, ...)
end)

mt.__index = newcclosure(function(self, k)
    if IsGunEquipped and Target and Pos and not IsStomping then
        if self == CachedMouse then
            if k == "Hit" then return CFrame.new(Pos) end
            if k == "Target" then return Part end
            if k == "X" then return Pos.X end
            if k == "Y" then return Pos.Y end
            if k == "Z" then return Pos.Z end
        end
    end
    return oldIdx(self, k)
end)

setreadonly(mt, true)
